1. Installer le Entity Framework (install-package EntityFramework) dans la console nuget;

2  Ajouter dans App.config la connexion vers le serveur SQL;

  <connectionStrings>
    <add name="DefaultConnection" connectionString="data source=.\POLYPLUS;initial catalog=ITrocDb;User Id=sa;Password=pp+.75LN; integrated security=SSPI" providerName="System.Data.SqlClient"/>
  </connectionStrings>

3. Cree la classe de la base de donnée qui herite de DbContext;

 public class PlutoContext : DbContext
    {        
        public PlutoContext()
            : base("name=DefaultConnection")
        {
        	this.Configuration.LazyLoadingEnabled = false; --desactiver le LazyLoading dans les applications Web pour performance;
        }
    }
4. Autoriser les migration EntityFramework avec la commande "enable-migrations";

5. Cree les modeles (Class) et les deplacer dans un nouveau repertoire nomée "models"; 

6. Ajouter les nouvelles Class(tables) dans DbSet<> fichier *context.cs de la migration;

7. Ajouter la migration pour la createion de la base de donnée et les tables definis dans "models" avec la commande 
add-migration AddDbAndNewTables. Si par erreur la migration est vide car on a oublié de signaler les nouvelles tables 
dans la class _Context.cs alors il faut relancer "add-migration AddDbAndNewTables -Force";

8. Apres avoir crée les tables pour obtenir le script de creation de toutes les tables il faut tapper la commande suivante:
"update-database -Script -SourceMigration:0";


9. Update-Database –TargetMigration:

----//Fluent API//

.ToTable("xxx") - override the table name;

.HasKey(c=>c.key_xxx) - set the primary key;

.Property(t=>t.Name)
.HasColumnName("changedName") - change the name of a Table & order of a column in a table;
.HasColumnOrder(2)

.Property(t=>t.Name)
.HasColumnType("changedTypeOfColumn" ex.varchar) - change the type of a columnt;

.Property(t=>t.Name)
.IsRequired();       - not null;
.HasMaxLength(255)   - override max length;


Ajouter une colonne comme Required avec FluentApi il faut ajouter ce code dans le *context.cs.
il faut overide la methode OnModelCreating et ajouter la ligne concernant la table corespondante:

protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Course>()
                .Property(p => p.Description)
                .IsRequired();



            base.OnModelCreating(modelBuilder);
        }

Relations multiples ou unique entre les tables:

Table A-------------->Table B	Table B-------------->Table A

HasMany()						WithMany()
HasRequired()					WithRequired()
HasOptional()					WithOptionl()

exemple:
many to one:
modelBuilder.Entity<Author>()
                .HasMany(a => a.Courses)
                .WithRequired(a => a.Author)
                .HasForeignKey(a => a.AuthorId);
many to many:
modelBuilder.Entity<Course>()
                .HasMany(c => c.Tags)
                .WithMany(c => c.Courses)
                .Map(m => m.ToTable("CourseTags"));
one to one:
modelBuilder.Entity<Course>()
				.HasRequired(c=>c.Cover)
				.WithRequiredPrincipal(c=>c.Course) ou .WithRequiredDependent(c=>c.Cover) en sens inverse

rennomer les collonnes des tables relationelles:
modelBuilder.Entity<Course>()
                .HasMany(c => c.Tags)
                .WithMany(c => c.Courses)
                .Map(m =>
                {
                    m.ToTable("CourseTags");
                    m.MapLeftKey("CourseId");
                    m.MapRightKey("TagId");
                });

one to many:
modelBuilder.Entity<Student>()
            .HasRequired<Grade>(s => s.CurrentGrade)
            .WithMany(g => g.Students)
            .HasForeignKey<int>(s => s.CurrentGradeId);  

Il faut organiser les Fluent Api dans des class diferentes ex.
cree un repertoire EntityConfigurations et une class "nom du class+Configuration.cs" ensuite deriver de la class generique 
"EntityTypeConfiguration<>" et ajouter un modelBuilder dans la *context.cs ex. "modelBuilder.Configurations.Add(new CourseConfiguration());"

ex. de classe:

public class CourseConfiguration : EntityTypeConfiguration<Course>
    {
        public CourseConfiguration()
        {

            ToTable("tbl_Course");

            HasKey(c => c.Id);

            Property(p => p.Description)
            .IsRequired()
            .HasMaxLength(2000);

            HasRequired(c => c.Author)
            .WithMany(c => c.Courses)
            .WillCascadeOnDelete(false);

            HasRequired(c => c.Cover)
            .WithRequiredPrincipal(c => c.Course);



            HasMany(c => c.Tags)
            .WithMany(c => c.Courses)
            .Map(m =>
            {
                m.ToTable("CourseTags");
                m.MapLeftKey("CourseId");
                m.MapRightKey("TagId");
            });


        }
    }


---------------------------------------------------Avoir les scripts
update-database -script -SourceMigration:xxxxxx(nom migration)

------//LINQ in EntityFramework


La requette est executer quand:

1. Iteration dans un foreach;
2. En appelant ToList,ToArray,ToDictionary;
3. En appelant First,Last,Single,Count,Max,Min,Average;

IQueryable -- la requette est composer en memeoir mais elle n'est pas executer;
IEnumerable -- la requette est executer a chaque expression Where , OrderBy;

pour utiliser le Eager Loading qui est fortement conseillé dans les applis Web, il faut ajouter le "using System.Data.Entity"
ensuite la querry ex. context.xxx.Include(c=>c.xxx.yyy);

faire un Incude avec une proprieté de type class et si de type collection alor il faut faire un Include(d=>d.xxx.Select(c=>c.xxx));



-----pour cree un Role Administrateur
dans le AccountController.cs il faut cree dans la methode Register(RegisterViewModel model)

*******

if(result.Succeeded)
{
	var roleStore =new RoleStore<IdentityRole>(new ApplicationDbContext);
	var roleManager = new RoleManager<IdentityRole>(roleStore);
	await roleManager.CreateAsync(new IdentityRole("Administrator"));
	await UserManager.AddToRoleAsync(user.Id,"Administrator");
}

apres il faut compiler et cree un utilisateur et il recevera le Role d'Administrateur ensuite il faut effacer les quatre ligne precedentes;


--------------------------------------------------------------
si dans la requette LINQ il y a un SingleOrDefault alor il faut faire une verif if(xxx==null) return BadRequest("Error");

----------------------------------------------------------------
integrer autocompletion dans une form Typeahead.js dans video The Complete ASP.NET MVC 5 Course\10-Building a Feature End-to-End Systematically/112-Adding Auto-completion
---------JS
pour inclure du html a partir du JS:
$("#xxx").append("<li>"+movie.name+"</li>"); -- avoir dans The Complete ASP.NET MVC 5 Course\10-Building a Feature End-to-End Systematically\113-Updating the DOM

---------------------
div.row>div.col-md-4.col-sm-4
--------------------------
Exemple d'AJAX pour valider une FORME dans The Complete ASP.NET MVC 5 Course\10-Building a Feature End-to-End Systematically\116-Submitting the Form
------------------------------
Pour afficher des messages succes ou erreur implementer le plugin JS toastr dans la video ASP.NET MVC 5 Course\10-Building a Feature End-to-End Systematically\117-Displaying Toast Notifications
-----------------------------------CLIENT SIDE VALIDATION
sur la vue ou on veut implementer la CSV il faut ajouter le script jqueryval : "@Scripts.Render("~/bundles/jqueryval")" en JS voir la video ASP.NET MVC 5 Course\10-Building a Feature End-to-End Systematically\118-Implementing Client-side Validation


-----UDEMY -- 95Sdjs7KBAzmDNq



---API MVC

il faut ajouter  {action} dans App_Start WebApiConfig.cs:
 config.Routes.MapHttpRoute(
                name: "DefaultApi",
                routeTemplate: "api/{controller}/{action}/{id}",
                defaults: new { id = RouteParameter.Optional }
            );